#[test]

/*
/* Fill in the blank and fix the error*/
fn factory(x:i32) -> __ {

    let num = 5;

    if x > 1{
        move |x| x + num
    } else {
        move |x| x + num
    }
}
*/

fn main() {
    let closure = factory(3);
    println!("{}", closure(1)); // Виведе: 6
}


fn factory(x: i32) -> Box<dyn Fn(i32) -> i32> {
    let num = 5;

    if x > 1 {
        Box::new(move |x| x + num)
    } else {
        Box::new(move |x| x + num)
    }
}

/*

impl Fn(i32) -> i32 означає, що функція повертає замикання, яке приймає i32 як аргумент і повертає i32.
Ключове слово move використовується для того, щоб замикання забрало власність на змінну num,
дозволяючи замиканню бути повернутим з функції навіть після того, як вона завершить виконання.

Тип повернення функції змінено на Box<dyn Fn(i32) -> i32>. Це дозволяє створювати замикання різних типів,
оскільки вони будуть "упаковані" в один динамічний тип.
В обох гілках if та else ми упаковуємо замикання за допомогою Box::new(...), що дозволяє повернути їх як тип Box<dyn Fn(i32) -> i32>.
У головній функції замикання тепер правильно обробляється і викликається.

*/