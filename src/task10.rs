#[test]

/*
/* Fill in the blank using two approaches,
 and fix the error */
fn create_fn() -> __ {
    let num = 5;

    // How does the following closure capture the environment variable `num`
    // &T, &mut T, T ?
    |x| x + num
}


fn main() {
    let fn_plain = create_fn();
    fn_plain(1);
}
*/

//1
/*fn main() {
    let fn_plain = create_fn();
    println!("{}", fn_plain(1));  // Виведе 6
}
fn create_fn() -> impl Fn(i32) -> i32 {
    let num = 5;

    // Використовуємо move, щоб замикання забрало власність на num
    move |x| x + num
}*/

//2
fn main() {
    let fn_plain = create_fn();
    println!("{}", fn_plain(1));  // Виведе 6
}
fn create_fn() -> impl Fn(i32) -> i32 {
    let num = 5;

    // Замикання захоплює num за значенням (по копії).
    move |x| x + num
}


/*

impl Fn(i32) -> i32: Ми використовуємо тип impl Fn(i32) -> i32 для позначення того,
що функція create_fn повертає замикання, яке приймає одне ціле значення і повертає ціле значення.
//1
Захоплення за посиланням (&T): Замикання використовує змінну num за посиланням,
тому воно може викликатися кілька разів без перенесення власності.
move: Ключове слово move змушує замикання захоплювати змінні з оточення по значенню.
Це означає, що num більше не буде позичене, а буде перенесено в замикання.
Завдяки цьому, життєвий цикл змінної num розширюється до життєвого циклу замикання,
що дозволяє замиканню бути повернутим із функції без помилок.
//2
Захоплення за значенням (T): Ключове слово move змушує замикання захоплювати змінну num за значенням, переміщуючи її в замикання.

*/
